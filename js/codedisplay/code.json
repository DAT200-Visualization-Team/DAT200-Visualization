{
  "javascript": {
    "stack": {
      "constructor": {
        "header": "function Stack() {",
        "lines": [
          "  this.arrayList = new ArrayList();"
        ]
      },
      "isEmpty": {
        "header": "Stack.prototype.isEmpty = function () {",
        "lines": [
          "  return this.arrayList.size() === 0;"
        ]
      },
      "makeEmpty": {
        "header": "Stack.prototype.makeEmpty = function () {",
        "lines": [
          "  this.arrayList.clear();"
        ]
      },
      "push": {
        "header": "Stack.prototype.push = function (element) {",
        "lines": [
          "  this.arrayList.add(element);"
        ]
      },
      "top": {
        "header": "Stack.prototype.top = function () {",
        "lines": [
          "  if (this.isEmpty())",
          "    throw { name: 'UnderflowException', message: 'ArrayList is empty' };",
          "  return this.arrayList.get(this.arrayList.size() - 1);"
        ]
      },
      "pop": {
        "header": "Stack.prototype.pop = function () {",
        "lines": [
          "  if(this.isEmpty())",
          "    throw { name: 'UnderflowException', message: 'ArrayList is empty' };",
          "  return this.arrayList.removeAtPos(this.arrayList.size() - 1);"
        ]
      }
    },
    "queue": {
      "constructor": {
        "header": "function Queue() {",
        "lines": [
          "  this.theArray = [];",
          "  this.currentSize = 0;",
          "  this.front = 0;",
          "  this.back = -1;"
        ]
      },
      "isEmpty": {
        "header": "Queue.prototype.isEmpty = function() {",
        "lines": [
          "  return this.currentSize === 0;"
        ]
      },
      "makeEmpty": {
        "header": "Queue.prototype.makeEmpty = function() {",
        "lines": [
          "  this.currentSize = 0;",
          "  this.front = 0;",
          "  this.back = -1;"
        ]
      },
      "increment": {
        "header": "Queue.prototype.increment = function(x) {",
        "lines": [
          "  x++;",
          "  if(x === this.theArray.length) {",
          "      x = 0;",
          "  }",
          "  return x;"
        ]
      },
      "enqueue": {
        "header": "Queue.prototype.enqueue = function(x) {",
        "lines": [
          "  if (this.currentSize === this.theArray.length) {",
          "      this.doubleQueue();",
          "  }",
          "  this.back = this.increment(this.back);",
          "  this.theArray[this.back] = x;",
          "  this.currentSize++;"
        ]
      },
      "dequeue": {
        "header": "Queue.prototype.dequeue = function() {",
        "lines": [
          "  if(this.isEmpty()) {",
          "      throw {name: 'UnderflowException', message: 'Queue is empty (dequeue)'};",
          "  }",
          "  this.currentSize--;",
          "  var returnVal = this.theArray[this.front];",
          "  this.front = this.increment(this.front);",
          "  return returnVal;"
        ]
      },
      "getFront": {
        "header": "Queue.prototype.getFront = function() {",
        "lines": [
          "  if(this.isEmpty()) {",
          "      throw {name: 'UnderflowException', message: 'Queue is empty (getFront)'};",
          "  }",
          "  return this.theArray[this.front];"
        ]
      },
      "doubleQueue": {
        "header": "Queue.prototype.doubleQueue = function() {",
        "lines": [
          "  var newArray = new Array(this.theArray.length * 2);",
          "  for(var i = 0; i < this.currentSize; i++, this.front = this.increment(this.front)) {",
          "      newArray[i] = this.theArray[this.front];",
          "  }",
          "  this.theArray = newArray;",
          "  this.front = 0;",
          "  this.back = this.currentSize - 1;"
        ]
      }
    },
    "hanoi": {
      "hanoi1": {
        "header": "function hanoi(disks, from, to, temp) {",
        "lines": [
          "    if (disks === 0)",
          "        return;",
          "    hanoi(disks - 1, from, temp, to);",
          "    console.log(\"Moving disc \" + disks + \" from \" + from + \" to \" + to);",
          "    hanoi(disks - 1, temp, to, from);"
        ]
      }
    },
    "linkedlist": {
      "constructor": {
        "header": "function LinkedList() {",
        "lines": [ "    this.head = new Node(null, null, null);", "    this.tail = new Node(null, this.head, null);", "    this.head.next = this.tail;", "    this.theSize = 0;", "    this.modCount = 0;", "}" ]
      },
      "clear": {
        "header": "LinkedList.prototype.clear = function() {",
        "lines": [ "    this.head = new Node(null, null, null);", "    this.tail = new Node(null, this.head, null);", "    this.head.next = this.tail;", "    this.theSize = 0;", "    this.modCount++;", "};" ]
      },
      "size": {
        "header": "LinkedList.prototype.size = function() {",
        "lines": [ "    return this.theSize;", "};" ]
      },
      "isEmpty": {
        "header": "LinkedList.prototype.isEmpty = function() {",
        "lines": [ "    return this.theSize === 0;", "};" ]
      },
      "add": {
        "header": "LinkedList.prototype.add = function(idx, data) {",
        "lines": [ "    var p = this.getNode(idx);", "    var newNode = new Node(data, p.prev, p);", "    newNode.prev.next = newNode;", "    p.prev = newNode;", "    this.theSize++;", "    this.modCount++;", "};" ]
      },
      "addFirst": {
        "header": "LinkedList.prototype.addFirst = function(data) {",
        "lines": [ "    this.add(0, data);", "};" ]
      },
      "addLast": {
        "header": "LinkedList.prototype.addLast = function(data) {",
        "lines": [ "    this.add(this.size(), data);", "};" ]
      },
      "removeNode": {
        "header": "LinkedList.prototype.removeNode = function(p) {",
        "lines": [ "    p.next.prev = p.prev;", "    p.prev.next = p.next;", "    this.theSize--;", "    this.modCount++;", "    return p.data;", "};" ]
      },
      "removeByIdx": {
        "header": "LinkedList.prototype.removeByIdx = function(idx) {",
        "lines": [ "    return this.removeNode(this.getNode(idx));", "};" ]
      },
      "removeFirst": {
        "header": "LinkedList.prototype.removeFirst = function() {",
        "lines": [ "    if (this.isEmpty()) {", "        throw {name: 'NoSuchElementException', message: \"List is empty.\"};", "    }", "    return this.removeByIdx(0);", "};" ]
      },
      "removeLast": {
        "header": "LinkedList.prototype.removeLast = function() {",
        "lines": [ "    if (this.isEmpty()) {", "        throw {name: \"NoSuchElementException\", message: \"List is empty.\"};", "    }", "    return this.removeByIdx(this.size() - 1);", "};" ]
      },
      "removeByData": {
        "header": "LinkedList.prototype.removeByData = function(data) {",
        "lines": [ "    var pos = this.findPos(data);", "    if (pos == -1) {", "        return false;", "    }", "    else {", "        this.removeNode(pos);", "        return true;", "    }", "};" ]
      },
      "getNode": {
        "header": "LinkedList.prototype.getNode = function(idx) {",
        "lines": [ "    var p;", "    if (idx < this.size() / 2) {", "        p = this.head.next;", "        for (var i = 0; i < idx; i++) {", "            p = p.next;", "        }", "    } else {", "        p = this.tail;", "        for (var i = this.size(); i > idx; i--) {", "            p = p.prev;", "        }", "    }", "    return p;", "};" ]
      },
      "set": {
        "header": "LinkedList.prototype.set = function(idx, newVal) {",
        "lines": [ "    var p = this.getNode(idx);", "    var oldVal = p.data;", "    p.data = newVal;", "    return oldVal;", "};" ]
      },
      "findPos": {
        "header": "LinkedList.prototype.findPos = function(x) {",
        "lines": [ "    for(var p = this.head.next; p !== this.tail; p = p.next) {", "        if (x === null) {", "            if(p.data === null) {", "                return p;", "            }", "        }", "        else if(x === p.data) { //must really use x.equals(p.data)", "            return p;", "        }", "    }", "    return -1;", "};" ]
      }
    },
    "fibonacci": {
      "naiveFib": {
        "header": "function naiveFib(n) {",
        "lines": [ "    if (n < 1)", "        throw new { name: \"IllegalArgumentException\", message: \"The Fibonacci numbers start at 1.\" };", "    if (n === 1) return 1;", "    if (n === 2) return 1;", "     ", "    return naiveFib(n - 1) + naiveFib(n - 2);", "}" ]
      },
      "iterativeFib": {
        "header": "function iterativeFib(n) {",
        "lines": [ "    if(n <= 0)", "        throw new { name: \"IllegalArgumentException\", message: \"The Fibonacci numbers start at 1.\" };", "    if (n === 1) return 1;", "    if (n === 2) return 1;", "     ", "    var nMinusOne = 1;", "    var nMinusTwo = 1;", "    var result = 0;", "     ", "    for (var i = 3; i <= n; i++) {", "        result = nMinusOne + nMinusTwo;", "        nMinusTwo = nMinusOne;", "        nMinusOne = result;", "    }", "     ", "    return result;", "}" ]
      },
      "dynFibConstructor": {
        "header": "function FibCalculator(n) {",
        "lines": [ "    this.oldNumbers = Array.apply(null, Array(n)).map(Number.prototype.valueOf, 0);", "    this.result = this.recursiveFib(n);", "}" ]
      },
      "dynFibGetResult": {
        "header": "FibCalculator.prototype.getResult = function () {",
        "lines": [ "    return this.result;", "};" ]
      },
      "recursiveDynFib": {
        "header": "FibCalculator.prototype.recursiveFib = function (n) {",
        "lines": [ "    if (this.oldNumbers[n - 1] != 0) return this.oldNumbers[n - 1];", "    if (n === 1) return 1;", "    if (n === 2) return 1;", "     ", "    this.oldNumbers[n - 1] = this.recursiveFib(n - 1) + this.recursiveFib(n - 2);", "    return this.oldNumbers[n - 1];", "};" ]
      }
    },
    "graph": {
      "dijkstra": {
        "header": "Graph.prototype.dijkstra = function (startName) {",
        "lines": [ "    var pq = new BinaryHeap();", "     ", "    var start = this.vertexMap[startName];", "    if (start === undefined || start === null) {", "        throw { name: \"NoSuchElementException\", message: \"Start vertex not found\" };", "    }", "    this.clearAll();", "    pq.add(new Path(start, 0));", "    start.dist = 0;", "     ", "    var nodesSeen = 0;", "    while (!pq.isEmpty() && nodesSeen < Object.keys(this.vertexMap).length) {", "        var vrec = pq.remove();", "        var v = vrec.dest;", "        if (v.scratch !== 0) { // already processed v", "            continue;", "        }", "        v.scratch = 1;", "        nodesSeen++;", "         ", "        for (var itr = v.adj.iterator(0) ; itr.hasNext() ;) {", "            var e = itr.next();", "            var w = e.dest;", "            var cvw = e.cost;", "             ", "            if (cvw < 0) {", "                throw { name: \"GraphException\", message: \"Graph has negative edges\" };", "            }", "             ", "            if (w.dist > v.dist + cvw) {", "                w.dist = v.dist + cvw;", "                w.prev = v;", "                pq.add(new Path(w, w.dist));", "            }", "        }", "    }", "};" ]
      },
      "bellmanford": {
        "header": "Graph.prototype.negative = function(startName) { // also called the Bellman-Ford algorithm",
        "lines": [ "    this.clearAll();", "     ", "    var start = this.vertexMap[startName];", "    if(start == null) {", "        throw {name: \"NoSuchElementException\", message: \"Start vertex not found\"};", "    }", "     ", "    var q = new LinkedList();", "    q.addLast(start);", "    start.dist = 0;", "    start.scratch++;", "     ", "    while(!q.isEmpty()) {", "        var v = q.removeFirst();", "        if(v.scratch++ > 2 * Object.keys(this.vertexMap).length) {", "            throw {name: \"GraphException\", message: \"Negative cycle detected\"};", "        }", "         ", "        for(var itr = v.adj.iterator(0); itr.hasNext(); ) {", "            var e = itr.next();", "            var w = e.dest;", "            var cvw = e.cost;", "             ", "            if(w.dist > v.dist + cvw) {", "                w.dist = v.dist + cvw;", "                w.prev = v;", "                // Enqueue only if not already on the queue", "                if(w.scratch++ % 2 === 0) {", "                    q.addLast(w);", "                } else {", "                    w.scratch--; // undo the enqueue increment", "                }", "            }", "        }", "    }", "};" ]
      }
    }
  }
}
